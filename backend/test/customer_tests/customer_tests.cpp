#include <gtest/gtest.h>
// Customer-related tests (post/get/patch)
// - "happy path" tests to verify the basic DB interactions work.
// - but we also have some tests for expected failure cases (e.g. missing required fields, uniqueness violations)

#include "db/db_connection.h"
#include "modules/customer/customer.h"
#include <pqxx/pqxx>
#include <chrono>
#include <optional>
#include <sstream>
#include <string>
#include <vector>

namespace
{
    // Used to make email/licence values unique across test runs.
    // (Avoids failing because of UNIQUE constraints in the DB.)
    std::string uniqueSuffix()
    {
        auto now = std::chrono::high_resolution_clock::now().time_since_epoch().count();
        std::ostringstream oss;
        oss << now;
        return oss.str();
    }

    // Deletes a customer by id (used in TearDown so tests don’t leave junk in the DB).
    void deleteCustomerById(pqxx::connection &conn, const std::string &id)
    {
        pqxx::work txn(guard.get());
        txn.exec_params("DELETE FROM Customers WHERE id = $1", id);
        txn.commit();
    }

    // Test fixture:
    // - makes one DB connection per test
    // - keeps track of created ids so it can be deleted after
    class CustomerDbFixture : public ::testing::Test
    {
    protected:
        void SetUp() override
        {
            guard_ = std::make_unique<ConnectionGuard>(getPool());
            suffix_ = uniqueSuffix();
        }

        void TearDown() override
        {
            if (!conn_)
                return;

            // Best-effort cleanup of created customers
            // It helps keep the DB clean.
            for (const auto &id : created_ids_)
            {
                try { deleteCustomerById(*guard_, id); }
                catch (...) {}
            }
            created_ids_.clear();
            guard_.reset(); // returns connection to pool
        }

        ConnectionGuard& guard() { return *guard_; }

        // Helper so each test can quickly create a valid customer.
        Customer makeCustomer(const std::string &first = "TestFirst",
                              const std::string &last = "TestLast",
                              const std::string &phone = "5190000000",
                              const std::optional<std::string> &address = std::optional<std::string>("123 Test St"))
        {
            Customer c = createCustomer(
                guard(), first, last, phone,
                "test" + suffix_ + "@example.com",
                "DL-" + suffix_,
                address);

            created_ids_.push_back(c.id);
            return c;
        }

        std::unique_ptr<ConnectionGuard> guard_;
        std::string suffix_;
        std::vector<std::string> created_ids_;
    };

} // namespace

// Create should succeed with valid data.
TEST_F(CustomerDbFixture, CreateCustomer_HappyPath)
{
    Customer created = makeCustomer();

    // id should be generated by DB, and email should look like an email.
    EXPECT_FALSE(created.id.empty());
    EXPECT_NE(created.email.find('@'), std::string::npos);
}

// Fetching by id should return the same customer we inserted.
TEST_F(CustomerDbFixture, GetCustomerById_ReturnsCreatedCustomer)
{
    Customer created = makeCustomer();
    auto fetched = getCustomerById(conn(), created.id);

    ASSERT_TRUE(fetched.has_value());
    EXPECT_EQ(fetched->email, created.email);
    EXPECT_EQ(fetched->driving_licence, created.driving_licence);
}

// List should include the customer we inserted.
TEST_F(CustomerDbFixture, GetAllCustomers_IncludesCreatedCustomer)
{
    Customer created = makeCustomer();
    auto all = getAllCustomers(conn());

    bool found = false;
    for (const auto &c : all)
    {
        if (c.id == created.id)
        {
            found = true;
            break;
        }
    }
    EXPECT_TRUE(found);
}

// Missing required fields should be rejected.
TEST_F(CustomerDbFixture, CreateCustomer_MissingRequiredFields_Throws)
{
    EXPECT_THROW(
        (void)createCustomer(guard(), "", "Last", "123", "x" + suffix_ + "@example.com", "DL-X" + suffix_, std::nullopt),
        std::invalid_argument);
}

// Invalid email should be rejected.
TEST_F(CustomerDbFixture, CreateCustomer_InvalidEmail_Throws)
{
    EXPECT_THROW(
        (void)createCustomer(guard(), "A", "B", "123", "not-an-email", "DL-Y" + suffix_, std::nullopt),
        std::invalid_argument);
}

// If email is UNIQUE in the DB, inserting the same email should fail.
TEST_F(CustomerDbFixture, CreateCustomer_DuplicateEmail_ThrowsUniqueViolation)
{
    Customer created = makeCustomer();

    EXPECT_THROW(
        (void)createCustomer(guard(), "Dup", "Email", "123", created.email, "DL-DUP-" + suffix_, std::nullopt),
        pqxx::unique_violation);
}

// If driving_licence is UNIQUE in the DB, inserting the same licence should fail.
TEST_F(CustomerDbFixture, CreateCustomer_DuplicateDrivingLicence_ThrowsUniqueViolation)
{
    Customer created = makeCustomer();

    EXPECT_THROW(
        (void)createCustomer(guard(), "Dup", "DL", "123", "other" + suffix_ + "@example.com", created.driving_licence, std::nullopt),
        pqxx::unique_violation);
}

// Patch should update only the fields we pass in.
TEST_F(CustomerDbFixture, PatchCustomer_UpdatesPhoneAndAddress)
{
    Customer created = makeCustomer();

    Customer updated = patchCustomer(
        guard(),
        created.id,
        std::nullopt,
        std::nullopt,
        std::optional<std::string>("5191111111"),
        std::nullopt,
        std::nullopt,
        std::optional<std::string>("999 Updated Ave"));

    EXPECT_EQ(updated.ph_number, "5191111111");
    EXPECT_EQ(updated.address, "999 Updated Ave");
}

// Patch should reject invalid email if provided.
TEST_F(CustomerDbFixture, PatchCustomer_InvalidEmail_Throws)
{
    Customer created = makeCustomer();

    EXPECT_THROW(
        (void)patchCustomer(
            guard(),
            created.id,
            std::nullopt,
            std::nullopt,
            std::nullopt,
            std::optional<std::string>("bademail"),
            std::nullopt,
            std::nullopt),
        std::invalid_argument);
}

// Patch with no fields shouldn’t be allowed.
TEST_F(CustomerDbFixture, PatchCustomer_NoFieldsProvided_Throws)
{
    Customer created = makeCustomer();

    EXPECT_THROW(
        (void)patchCustomer(guard(), created.id, std::nullopt, std::nullopt, std::nullopt, std::nullopt, std::nullopt, std::nullopt),
        std::invalid_argument);
}

// If email is UNIQUE, patching an email to another customer’s email should fail.
TEST_F(CustomerDbFixture, PatchCustomer_UniquenessConflictOnEmail_ThrowsUniqueViolation)
{
    Customer c1 = makeCustomer();

    // Creates a second customer with a different unique email/licence.
    std::string other_suffix = uniqueSuffix();
    Customer c2 = createCustomer(
        guard(),
        "Other",
        "Customer",
        "5192222222",
        "other" + other_suffix + "@example.com",
        "DL-OTHER-" + other_suffix,
        std::nullopt);

    created_ids_.push_back(c2.id);

    // Attempt to patch c2’s email to c1’s email, which should violate the UNIQUE constraint.
    EXPECT_THROW(
        (void)patchCustomer(
            guard(),
            c2.id,
            std::nullopt,
            std::nullopt,
            std::nullopt,
            std::optional<std::string>(c1.email),
            std::nullopt,
            std::nullopt),
        pqxx::unique_violation);
}